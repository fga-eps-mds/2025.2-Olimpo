version: "3.9"

services:
  db:
    image: postgres:16-alpine
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: 200274
      POSTGRES_DB: course2

    ports:
        - "5432:5432"

    volumes:
      - ./postgres_init:/docker-entrypoint-initdb.d
      - postgres_data:/var/lib/postgresql/data

  # --- Nosso novo serviço da API Spring Boot ---
  app:
    # "build: ." diz ao Docker Compose para procurar um Dockerfile no diretório atual e construí-lo
    build: ./olimpo
    ports:
      # Expõe a porta 8080 da API para a sua máquina local
      - "8080:8080"
    # "depends_on" faz o Spring esperar o banco de dados (db) estar pronto antes de iniciar
    depends_on:
      - db
    # "environment" é a parte CRUCIAL. Isso sobrescreve o application.properties
    # para que a API possa encontrar o banco DENTRO da rede do Docker.
    environment:
      # O host não é "localhost", é o NOME DO SERVIÇO do banco: "db"
      SPRING_DATASOURCE_URL: jdbc:postgresql://db:5432/course2
      SPRING_DATASOURCE_USERNAME: postgres
      SPRING_DATASOURCE_PASSWORD: 200274
      # Esta linha é boa para garantir que o Hibernate crie/atualize as tabelas
      SPRING_JPA_HIBERNATE_DDL_AUTO: update
      # Credenciais de e-mail (usadas pelo application.properties via ${MAIL_USER}/${MAIL_PASS})
      MAIL_USER: ${MAIL_USER}
      MAIL_PASS: ${MAIL_PASS}
      # sobrescrever diretamente as propriedades Spring Mail
      SPRING_MAIL_USERNAME: ${MAIL_USER}
      SPRING_MAIL_PASSWORD: ${MAIL_PASS}
      SPRING_MAIL_HOST: smtp.gmail.com
      SPRING_MAIL_PORT: 587
      SPRING_MAIL_PROPERTIES_MAIL_SMTP_AUTH: "true"
      SPRING_MAIL_PROPERTIES_MAIL_SMTP_STARTTLS_ENABLE: "true"

volumes:
  postgres_data: